操作系统的特征：
1 并发性 一段时间内多道程序同时执行
2 共享性 共享是指系统中的所有资源不再为一个程序独占，同时被多个程序共同使用。
3 虚拟性 虚拟是指通过某种技术吧一个物理实体变成若干逻辑上的对应物
4 异步性 多道程序环境下，允许多个程序并发执行，由于资源限制，程序执行走走停停的方式运行。
操作系统的功能
1处理机的管理  2存储管理 3文件管理 4 设备管理 5用户接口
操作系统提供的服务
1  程序执行  2 I/O操作  3 文件系统操作  4 通信 5 错误检测和处理 6 资源分配 7 统计 8保护
操作系统提供两类接口：一类是命令接口；另一类是程序接口。
在操作系统中，实现系统调用功能的机制成为陷入或异常处理机制。程序执行系统调用，是通过终端机构来实现，需要从用户态转变到核心态。当系统调用返回后，继续执行用户程序，同时CPU从核心态切换到用户态。
响应时间是分时系统最重要的指标，它是用户发生终端命令道系统做出响应的时间间隔。
操作系统内核是操作系统中关键部分，它是管理控制中心。内核在核心态下运行，常驻内存，内核通过执行各种操作来实现各种控制和管理功能。
在操作系统中，为控制和实现系统调用的机制成为陷入或异常处理机制，相应的由于系统调用而引起处理器中断的机器指令称访管指令或陷入指令。系统调用需要触发Trap指令，如基于x86的linux系统，该指令为int 0x80或sysenter
微内核结构把操作系统的很多服务移到内核以外（如文件系统），服务直接使用进程间通信机制进行信息交流，这种通过进程间通信机制进行信息交换影响了系统的效率。
引入并发处理后导致操作系统的三个复杂性1分时技术 2资源保护 3死锁预防
为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（PCB Process Control Block）。进程上下文由进程的PCB保存。
进程特性 1 动态性 2 独立性 3并发性 4 结构化
进程和程序的区别和联系
1 进程是动态的 程序是静态的 进程是程序的执行
2 进程是暂时的 程序是永久的
3 程序和进程的组成不同  进程的组成包括程序数据和进程控制块（即进程状态信息）
4 进程和程序密切相关 通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可以包括多个程序。进程可以创建新的进程，而程序并不能形成新的程序。
进程的三个基本状态是 就绪状态 运行状态和等待或阻塞状态。
进程的控制：1 创建 2 撤销 3 阻塞  4 唤醒
进程是个抽象的概念。但是需要一个具体的代表参与管理，这就是进程控制块（PCB）。 每个进程都有唯一的PCB与之对应。进程做队列中的切换其实是PCB在队列中的转换；对进程的控制，实际上就是对进程PCB的控制。
进程控制块包括1 进程状态 2程序计数器 3 CPU寄存器 4 CPU调度信息 5 内存管理信息 6 记账信息 7 I/O状态信息
进程上下文实际上是进程执行活动全过程的静态描述。  unix操作系统中上下文（进程映象）包括三部分：1 用户级上下文 2 系统级上下文 3 寄存器上下文
操作系统提供了多种进程间操通信机制
1 共享存储机制 在内存中划出一块存储区，供多个进程共享。 共享存储器是进程通信速度最快的一种通信机制，且可以实现大量数据传送。
2 消息传递机制 以消息为单位，因实现方式不同，分为直接通信和间接通信两种。 机制需要两条原语 send 和 receive
直接通信通过send和receive，两个操作建立一个连接。
间接通信把消息暂存到共享数据结构组成的队列，叫信箱。 灵活 可以一对一 一对多 信箱常被称为端口
3管道通信机制 管道是指用于连接一个读进程和一个写进程，以实现他们之间通信的共享文件，又称为管道文件。 
管道分为有名管道和无名管道。无名管道是存在于文件系统的临时文件，没有文件路径名。有名管道是做文件系统中存在的，其他进程可以知道它的存在并可以利用路径名来访问该文件。
线程定义为进程内一个执行单元或一个可调度实体。 在不拥有线程的进程概念中，进程既是一个拥有资源的独立单位，它可以独立分配虚地址空间，主存和其他；又是一个可独立调度和分派的基本单位。
有了线程之后，资源拥有单位成为进程，调度单位称为线程，又称轻进程LWP。
从实现的角度看，把线程分为用户及线程和内核级线程。
有三种不同模型将用户级线程和内核级线程关联起来：多对一模型将多个用户线程映射到一个内核线程，一对一模型将每个用户线程映射到一个相应的内核线程，多对多模型将多个用户线程在同样数量的内核线程之间切换。
处理机调度
负责动态的把处理器分配给进程或内核级线程，也称为CPU调度或进程调度。
按照调度所涉及的层次的不同，可把处理器调度分成高级调度，中级调度和低级调度三个层次。
高级调度也成为作业调度或宏观调度。
中级调度涉及进程在内外存间的交换。
低级调度也称为微观调度。在处理器资源分配的角度来看，处理器需要经常选择就绪进程或线程进入运行状态。
上下文切换时间是额外开销，因为切换时系统并不能做任何用户进程要求的工作。
面向用户的准侧和评价
1周转时间短 2响应时间快 3 截止时间的保证 4优先权准则
面向系统的准则
1达到系统设计的目标 2系统吞吐量大 3处理机利用率高 4各类资源的平衡利用
调度方式可采用两种方式：1非抢占方式 2抢占方式：a时间片原则 b优先权原则
调度算法：1先来先服务FCFS    短进程等待非常长的进程。所谓Belady现象是指：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。
2.最短作业/进程优先 SJF/SPF  会产生饥饿，老化技术可以解决
3.时间片轮转RR   时间片大小选择 太大就是FCFS
4优先级
5高响应比优先HRRN  响应比=（进程已等待时间+进程要求运行时间）/进程要求运行时间  FCFS和SJF的折中
6多队列调度MQ  最为常用的是前台交互队列（RR）和后台批处理队列的组合（FCFS）
7多级反馈队列MFQ 
进程同步  确保在任何时刻最多只能有一个进程执行这些访问共享数据的代码，这就是临界区互斥问题。
一次只运行一个进程使用的资源称为临界资源（独享资源）。进程中访问临界资源的那部分代码称为临界区。共享资源：类似硬盘等运行进程间共享，即可交替使用的。
进程同步机制遵循的准则：1互斥 当有进程进入自己的临界区，其他试图进入临界区的进程必须等待，以保证进程互斥的访问临界资源。
2空闲让进  当无进程进入自己的临界区，相应的临界资源处于空闲状态，允许一个亲请求进入临界区的进程立刻进入自己的临界区。
3有限等待 对要求访问临界资源的进程，应该保证进程能在有限时间进入临界区，以免陷入饥饿装填。
让权等待，在多处理机中忙等是产检的。
实现临界区互斥的基本方法
1软件实现法  peterson算法
2硬件实现法 TestAndSet指令 SWAP指令 Exchange指令
3信号量  12解决方法的确定是他们都需要忙等待，信号量可以克服这个问题。信号量本质就是整型变量，只不过它只能又P操作,V操作（wait，signal）和初始化去访问他。
p操作代表分配资源，v操作代表释放资源，p和v都是原子操作。
定义：  
typedef struct {
	int value;
	struct process* L;
}semaphore;
s为信号量 s->L表示等待队列， value表示信号量的值。
（1）value>0 表示有value个资源可用  （2） value=0 无资源可用 （3）value<0 表示有|value|在等待队列或者等待进入临界区
	信号量按用途分为两类
	（1）互斥信号量（公用信号量）  为一组互斥共享临界资源的并发进程设置，代表共享的临界资源，每个进程可对它进行PV操作。其初始值为1
	（2）同步信号量（专用信号量，技术信号量）为一组序同步协作完成任务的并发进程而设置，只有拥有该资源的进程施加p操作（申请资源），其合作进程对它施加V操作。
PV操作。  p为申请一个资源 v表示释放一个资源
P(semaphore * S) {
	S->value--;
	if (S->value < 0) {
		add this process to s->L;
		block();
	}
}
V(semaphore* S) {
	S->value++;
	if (S->value <=0) {
		add a process P from s->L;
		wakeup(P);
	}
}
1 PV操作必须成对出现，有一个P就有一个V。多数情况下，当为互斥操作时，他们同处于同一进程。当为同步操作时，他们不处于同一进程。
2 如果两个P操作相邻，那么他们的顺序至关重要，而两个相邻的V操作顺序不关紧要。一个同步P和一个互斥P在一起时，同步P在前面。
利用信号量机制描述前趋关系。
semaphore : S = 0;
main()
cobegin {
C1: { Compute; V(s); }
P1: { P(S); Print; }
}coend
利用信号量机制实现进程互斥  设置一个互斥信号量mutex, 并设其初值为1
semaphore : S = 0;
main()
cobegin {
Pi:
	while (1) {
		P(metex);
		critical section
			V(mutex);
		remainder section
	}
}
利用信号量机制实现进程同步
semaphore empty = 1, full = 0;
main()
cobegin {
C:
	while (1) {
		compute next number;
		P(empty);
		add to buffer;
		V(full);
	}
P:
	while (1) {
		P(full);
		take from buffer;
		V(empty);
		print last number;
	}
}
管程 是一种高级同步结构.把系统中的资源用数据结构抽象的表示出来。代表共享资源的数据及其上操作的一组过程就构成了管程，管程被请求和释放资源的进程所调用。
管程的数学1共享性 2安全性 3互斥性
用信号量解决经典同步问题
1。生产者消费者问题
2 读者写者问题
3哲学家进餐问题
死锁  首先存在一个相关进程的集合，集合进程数大于等于2，否则单进程永远无法产生死锁。其次进程集合里面的进程都有申请资源的需求，而且被申请的资源类型都只能互斥使用。
还需满足四个条件1 互斥 2 占有并等待 3非抢占 4循环等待
死锁的避免方法是在资源的动态分配过程中, 用某种方法去防止系统进入不安全状态而避免死锁。
银行家算法，其指导思想就是确保系统始终处于安全状态。开始系统处于安全状态，当进程申请一个可用的资源时，系统必须确保分配完这一资源后，系统仍处于安全状态。
操作系统用来检查系统状态从而确定是否出现了死锁的算法，即死锁检测算法；采用银行家算法的思想，其中也用到安全状态判断算法。
两者的差别只不过在于银行家算法是事先判断，死锁检测算法是事后判断。
一个进程被唤醒意味着进程状态变为就绪。
线程结构体中包括线程标识符，程序计数器，寄存器集，栈空间等 每个线程都有自己的栈。
系统中进程的创建一般由父进程调用进程创建原语来创建。
用户进程的撤销是由于进程运行的正常或不正常结束而撤销，没有其他因素。
忙等待是指做临界区问题中，若一个进程做临界区，当其他进程欲进入临界区时，反复检测是否可以进入，即忙于等待临界区中的进程。
为什么自旋锁不适合于单处理系统而做多处理机系统中是有用的？
当一个进程欲访问已被其他进程锁定的资源时，进程循环检测该锁是否被释放，这种技术成为自旋锁。
施加自旋锁意味着进程一直占用CPU。在单处理机系统中，如果进程循环等待其他进程释放锁，因为系统只有一个CPU，拥有锁的进程无法得到CPU而被释放该锁，因此该进程应该阻塞么不是循环等待。
在多处理机系统中，循环等待被其他进程施加的锁是可行的，因为其他进程很有可能做别的CPU上执行，从而很快释放该锁。
什么是饥饿？死锁和饥饿的主要差别是什么？
饥饿并不表示系统一定死锁，但至少有一个进程的执行被无限期地推迟。
差别1.必须进入饥饿状态的进程可以只有一个，而由于循环等待条件，进入死锁状态的进程却必须大于或等于两个。
2.处于饥饿状态的进程可以是一个就绪进程，如静态优先权调度算法时的低优先权就绪进程，而处于死锁状态的进程则必定是阻塞进程。
银行家算法的数据结构
1.可用资源向量Available[m].m为系统中资源种类数，其初始值是系统中所配置的各类可用资源项目。 Available[j] = k表示系统中低j类资源数为k个，其数值随该类资源分配和回收动态地变化。
2最大需求矩阵Max[n, m].n为系统中进程数，Max定义了系统中n个进程中每个进程对m类资源的最大需求。Max[i, j] = k表示进程Pi对j类资源的最大需求数
3.分配矩阵Allocation[n，m] 它定义了系统中每一类资源当前已分配给每一进程资源数，Allocation[i，j] = k表示进程Pi已分得j类资源的数目为k个。
4需要矩阵Need[n, m].表示每个进程尚需的各类资源数，Need[i, j] = k表示进程Pi还需要j类资源k个。Need[i, j] = Max[i, j] - Allocation[i，j]
银行家算法。假设进程并发执行时进程Pi提出请求j类资源k个后，表示为Requesti[j] = k.系统按下述步骤开始安全检查：
1.如果Request <= Need则继续检查，否则显示需求申请超出最大需求之的错误
2.如果Request <= Allocation则继续检查，否则显示系统无足够资源，Pi阻塞等待。
3.系统试探吧要求的资源分配给进程Pi并修改有关数据结构的数值：
Available = Available - Request;
Allocation = Allocation + Request;
Need = Need - Request;
4系统调用安全检查算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则将试探分配作废，恢复原来的资源分配状态，让进程Pi等待。
产生死锁的两个原因是竞争资源引起死锁和进程推进顺序不当引起死锁。

