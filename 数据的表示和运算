重载运算符是具有特殊名字的函数，他们的名字由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载运算符也包含返回类型，参数列表以及函数体。
类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。 operator type() const;
类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变转换对象的内存，因此，类型转换运算符一般被定义成const成员。
先序遍历  后序遍历  中序遍历    层序遍历
avl树是带有平衡条件的二叉查找树。最简单的想法是要求左右子树具有相同的高度。另一个平衡条件是要求每个节点都必须要有相同高度的左子树和右子树。
一颗avl树是其每个节点的左子树和右子树的高度最多差1的二叉查找树。
伸展树保证从空树开始任意连续M次对树的操作最多话费O(MlogN)时间。伸展树的基本想法是，当一个节点被访问后，它就要经过一系列AVL树的旋转后放到根上。
在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。
B树 常用的不是二叉树的查找树。
阶为M的B树是一颗具有下列结构特性的树：1.树的根或者一片树叶，或者其儿子数在2和M之间。2.除根外，所有非树叶节点的儿子数在[M / 2]和M之间。3.所有树叶做相同的深度上。
B树实际用于数据库系统，做那里树被存储在物理的磁盘上而不是主存中。一般来说对磁盘的访问要比任何主存操作慢几个数量级。
理想的散列表数据结构只不过是一个含有关键字的具有固定大小的数组。
解决冲突的方法 分离链接法和开放定址法
分离链接法将散列到同一个值的所有元素保存做一个表中。缺点是需要指针，速度有所减慢。做开放定值散列法中，如果有冲突发生，那么就要尝试选择另外的单元，直到找到空的单元为止。
1.线性探测法 2.平方探测法 3.双散列
再散列 可扩散列
实现优先队列的常用工具是二叉堆 两个性质 结构性和堆序性 堆是完全二叉树 可以用数组表示  通过堆序性可以找到最小元
d - 堆  左式堆跟二叉堆的唯一区别是 左式堆不是理想平衡的，实际上是趋向于非常不平衡的。
任意节点x的零路径长NPL（X）定义从X到一个没有两个儿子节点的最短路径的长。NPL（NULL）=-1  
左式堆的性质是：对于堆中的每一个节点X，左儿子的零路径长至少与右儿子的零路径长一样大。  斜堆是左式堆的自我调节形式。
二项队列 不是一颗堆序的树，而是堆序树的集合，成为森林。每一个高度上最多存在一颗二项树。
假设CPU有20根地址线和32根数据线，试问按字节和字寻址，寻址范围是多少？                                
假设CPU有20根地址线，32根数据线，试问按字节和字寻址，寻址范围分别是多少？

解答：首先，默认情况下，地址线的位数对应的都是按字节寻址。但是如果题目中数据线就只有4根，还当默认按字节寻址，那就大错特错了。因为数据线才4根，一次读写只能4个bit，根本不可能做到按字节寻址，这里的数据线有32根。所以可以大胆放马过来。

如果是按字寻址，就需要拿出地址线做字内字节寻址。因为，一个字有多个字节。寻址本身和数据线没有任何关系。要的是，能够索引到相应字节，而数据线位数，可以显示的是字内有多少字节，从而决定分配多少地址线来。

好了，按字节寻址：20根地址线，寻址范围就是220 = 1M220 = 1M。

按字寻址，因为数据线有32位，所以一个字有4字节。拿出两根地址线来(00 01 10 11)，剩下18根地址线，所以寻址范围是256K(218)256K(218)，即，可以数到252K个字，再由字内寻址，可以定位到每一个字节。

想不想问，多少个字节总共？

这个很容易想到，最多是220220个字节。两种方式都一样。如果是64位数据线呢，20位地址线，拿出3根做字内寻址，还剩17根做字寻址。还是一样的，只有220220个字节。

计算机如何判断取出的是数据还是指令？
1.通常完成一跳指令可以分为取值阶段和执行阶段。取值阶段，通过访问寄存器将指令取出，执行阶段，将操作数取出。cpu通过不同阶段判断二级制代码。
2.指令寄存器的操作码送入操作码译码器进行译码，伴随一个时间信号同时送入控制器。一个操作 + 一个时间
3.指令的地址码需要送入地址形成部件。若是转移地址，则送入pc；若是操作数地址，送入寄存器的地址译码器去去操作数，取出的操作数放在程序寄存器，然后送往运算器运算。
4.每读取一条指令，pc + 1
5.重复1234，到打印出结果，最后执行停机指令，机器自动停机。
冯诺依曼计算机的特点：
1.计算机由运算器，存储器，控制器，输入设备和输出设备五大部件组成。
2.指令和数据以同等地位保存于存储器内，并可按地址访问寄存器。
3.指令和数据均用二进制代码表示。
4.指令由操作码和地址码组成，操作码用来表示操作的性质，地址码表示操作数做存储器中的位置。
5.指令做存储期内按顺序存放。通常指令是顺序执行的，特定条件下 ，可根据运算结果或设定的条件改变执行顺序。
6.机器以运算器为中心，输入 / 输出设备和存储器直接的数据传送通过运算器来完成。
冯诺依曼计算机以运算器为中心，其他部件通过运算器完成信息的传递。现代计算机组织结构逐步转化为以存储器为中心。
计算机性能指标 1.吞吐量：主要取决于主存的存取周期 2.响应时间：从提交作业到得到cpu相应的时间 3.主频：机器内部时钟的频率 4.cpu周期 ：从内存读取一条指令的最短时间 5.cpu时钟周期：主频的倒数 cpu中最小的时间单位
6.CPI执行一条指令所需要的时钟周期数，MIPS每秒可执行百万条指令数FLOPS每秒执行的浮点运算次数。 7.CPU执行时间指cpu对特定程序的执行时间。
指令周期：从一条指令启动到下一条指令启动所经历的时间，通常由多个机器周期组成。
机器周期（cpu周期）把一条命令划分为多个阶段，每个阶段完成一项工作。完成一个基本操作需要的时间成为机器周期。
程序状态字PSW是计算机系统的核心部件，属于控制器的一部分.PSW用来存放两类信息：1.当前指令执行结果的各种状态信息 2.存放控制信息，如允许中段。有些机器中将PSW成为标志寄存器FR
指令寄存器用来存放当前正在执行的指令，因此指令寄存器的位数取决于指令字长。
地址总线宽度决定了CPU可以访问的物理地址空间，简单的说就是CPU到底能够使用多大容量的内存。
计算机内部为什么用二级制来编码所有信息？
1.二级制系统只有两个基本符号0和1.所以它的基本符号少，易于用稳定电路实现。
2.二级制的编码，计数，运算等的规则简单。
3.二级制中的0和1与逻辑命题的真和假的对应关系简单。
BCD码 二进制编码的十进制数是以二进制数来编码表示。
8421BCD码每一位为对应的四位二进制代码，再用十六进制C表示 + D表示 - ，而且放在数字串的最后。  1001进位不像普通的二进制1111进位
（101001）bcd    可以4位划分一组，不够就做高位补0.
余3码 8241基础上加上3（0011）形成。
国标码 = (区位码)16 + 2020H  汉纸内码 = (国标码码)16 + 8080H
检错编码：就是通过一定的编码和解码，能够做接受端解码时检查出传输的错误，但不能纠正错误。常见的有奇偶校验码和循环冗余校验（CRC）码
1.奇偶校验码就是做信息吗的基础上加一个校验码 奇校验：添加一位校验码，是整个码里面1的个数是奇数。 偶校验 1的个数是偶数   实际使用又分垂直奇偶校验 水平奇偶校验与水平垂直奇偶校验
2.CRC循环冗余校验码 奇偶校验检错率低不实用，广泛使用的是CRC  这种编码基本思想是将要传送的信息M(X)表示为一个多项式L，用L除以一个预先确定的多项式G(X)，得到的余式就是所需的循环冗余校验码
3海明码 在接收端不但能检查出错误，还能将检查出来的错误纠正。  假设信息为有K位，整个码字就是K + R 有R位就有2R次方状态 若果还要一种状态来表示正确，2 ^ r >= k + r + 1
海明码求解步骤1.确定校验码的位数r，2.确定校验码的位置，3.确定数据的位置 4.求出校验位的值
D = 101101的海明码 1. 2 ^ r >= 7 + r 2.位置2 ^ i - 1 3填入 4.每个数据妈由多个校验码共同校验，满足一个调剂 被校验数据码的海明位号等于校验该数据的各校验码海明位号之和，且校验码不需要再被校验。
校验位pi的值即为所有需要pi校验的数据位求异或
校验海明码的过程1.直接写出出错位和位置对应的关系 计算出错位的值 2求出二进制出错位的值对应十进制的值，此十进制数就是出错的位数，取反得到正确的编码。
定点数的表示 1.三种机器数的最高位均为符号位 符号位和数值直接可用.或，隔开
2.当真值是正数时，原码补码和反码的表示形式均相同，即符号位用0表示，数值部分与真值相同
3.当真值为负，三种表示形式不同，但符号位都用1表示，而数值部分，补码是原码的每位求反加1，反码是原码的每位求反。
0的原码和反码都有两种，补码只有一位的一种。 移码就是补码的符号位取反
大多数计算机系统采用补码来表示机器数1。x + (-x) = 0 2.0只有一种 3 符号位和数位一起参加运算 4.可以将减法转化为假发 5.方便解决补码数的扩充。
补码性质总计：1.无论机器字长是多少， - 1的补码用于全是1
2.最小附属的补码永远是首位为1后面全是0
3，补码比原码和反码多表示一位数。
1.逻辑移位：逻辑左移时，高位移丢，低位补0；逻辑右移时，低位移丢，高位添0.
2.算术移位 分析任意负数的补码可知，当对其由低位向高位找到第一个1时，以这个1为分界，在此1左边的各位均与对应的反码相同，1右面的各位与对应原码相同。
规则1.当机器数为正 原码补码反码都是补0
2.当机器数为负 原码  保持符号位不变 其余空位添0    反码 反码各位与原码正好相反 因此移位后全添加1   补码 左移添0 右移添1
原码的加法：相同绝对值相加 符号不变，不同 绝对值大的减去绝对值小的，结果符号与绝对值大的数相同
减法：将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。
补码的加法：[x + y]补 = [x]补 + [y]补[x - y]补 = [x]补 + [-y]补
溢出 两数相加大于上届127，正溢出；小于下届 - 128，，负溢出。
计算机怎么判断溢出？三种方法
1.从两个数的符号位出发  不管是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数的符号不同，即认为溢出。
2.通过数值部分最高位的进位和符号位产生的进位进行异或操作。1为溢出，0位无溢出。
3采用两位符号位的补码，变形补码，以4位模的。特点 两位符号位要两桶数值部分一起参加运算。高位符号位产生的进位直接丢弃
原则：两位符号位不同时，表示溢出，否则，则无溢出。无论是否发生溢出，高位符号位永远代表真正的符号位。
原码一位乘 符号位异或 数值部分相乘。 将乘法改进乘加法  原码两位乘 需要标志位cj触发器
计算机需要设计三个寄存器：一个寄存器存放被乘数，一个寄存器存放乘数以及乘积的低位u，一个寄存器存放乘积的高位。
补码一位乘 1.校正法 对于补码一位乘，当乘数y为正，不管x符号如何，都按照原码乘法计算，但是以为按照补码的算术移位来操作。当乘数y为负，不管x符号如何，都按照原码乘法计算，但是以为按照补码的算术移位来操作，并需要做结果上加上[-x]补来校正
2.比较法（both算法）
{ 1被乘数与部分积取双符号位，并且符号位参与运算
2乘数取单符号位以决定最后一步是否需要验证，即是否加[-x]补
3乘数末尾增设附件位yn + 1，初始为0
4根据yn yn + 1判断位，进行运算，步骤同上。
5按上述算法进行n + 1步，但第n + 1步不再移位，仅根据y0 y1比较结果决定是否要加减[x]补。
6按补码移位规则，即部分积为正时，右移过程中有效位最高位补0，部分积为负时，右移过程中有效位最高位补1。双符号的移位前面讲过，次高符号位参与移位，最高符号位不参与。 }
补码两位乘  两个定点小数相乘，不可能会溢出，两个绝对值小于1的数相乘，结果的绝对值不可能大于1.
两个定点整数相乘可能会溢出，也可能不会溢出。溢出的条件：乘积 > 定点格式表示的最大数。
原码除法和补码除法。又分为恢复余数发和不恢复余数法(加减交替法)
1.原码恢复余数法 由于小数的取值范围所限，因此小数定点除法对被除数和除数有一定的约束 0 < | 被除数 | < | 除数 |
	步骤{
	1.符号位单独处理，分别取数值的绝对值进行运算
	2.判断是否满足0 < | 被除数 | < | 除数 |
		if (| 被除数 | -| 除数 | >= 0)
			溢出，停止运算；
		else
			除法合法，进入3；
	3.若余数为正，表示够减，商上1，左移一位，减去y补；若余数为正，表示够减，商上1，左移一位，减去y补
	4.重复上一步骤n次，用计数器来控制循环次数，到n就停止。
	5.若最后一次余数为负，需要恢复余数，即加上余数，否则不需要。
}
从上述步骤可以看出 具有n位尾数的合法除法，需要逻辑移位n次，上商n + 1次。
缺点：在利用原码恢复余数法时，虽然上商和移位的步骤是确定的，但是在计算过程中，需要恢复多少次余数是不确定的，电路的设计会复杂很多。为了不恢复余数出现了新的方法。
2.原码不恢复余数法（加减交替法）
当余数大于0，恢复余数是将余数左移一位，减去除数。当前余数为R，下一步余数为R'=2R-y*
当余数小于0，恢复余数是先恢复余数，将余数左移一位，减去除数。当前余数为R，下一步余数为R'=2（R+y*）-y*=2R+y*
1.如果定点纯小数的除法运算，应该满足满足0 < | 被除数 | < | 除数 |，如果是定点纯整数的除法运算，应该满足满足0 < | 被除数 | <= | 除数 | 否则会溢出。定点整数除法的算法和定点小数算法一样，不再重复。
2.实现除法运算时，应该尽量避免为0或被除数为0。除数为0，结果为无限大，机器不能表示这个书；被除数为0，结果一定为0.实际上在除法运算前，首先检测被除数和除数是否为0，这两种情况都无需继续除法运算。
3.上述算法的左移余数，其实可以用右移除数来代替，但是比较复杂，所以不常用。
补码不恢复余数法(加减交替法)
计算机内存如何实现填充(扩展)操作？
在计算机内部，有时常需要将一个取来的短数扩展为一个长数，此时要进行填充处理。对于无符号数，只要在高位补0，进行零扩展。对于有符号数可能有两种情况：
1.对于定点整数，在符号位后的数值高位进行。原码 符号位不变，数值部分高位补0.补码 高位直接补符号，称为符号扩展方式。
2.对于定点小数表示的浮点数的尾数，则在低位补0即可。
为什么要引入浮点数表示？
因为定点数不能表示实数，而且表示范围小。所以要引入浮点数表示。
为什么要浮点数的阶用移码表示？
因为在浮点数的加减运算中，要进行对阶操作，所以需要比较两个阶的大小。移码表示的实质就是把阶加上一个偏置常数，使所有数的阶码都是一个正整数，
浮点数如何表示0？
用一种专门的位序列表示0，IEEE754单精度浮点数中，用0000 0000H表示+0，用8000 0000H表示-0。当运算结果出现阶码过小时，计算机将该数近似表示为0.
假设尾数为W，且基数为2，且当1>|2|>=1/2时，此浮点数为规格化数。浮点数的尾数用原码和补码来表示
1，使用原码表示尾数时，要使1> | 2|>=1 /2，尾数第一位必须为1。尾数形式0.1xxx 或者1.1xxxx
2，当补码表示尾数，要使1>| 2|>=1 / 2，浮点数为正数时，尾数第一位必须为1。浮点数为复数，最高位必须为0，否则求返加一会小于1/2.  尾数形式00.1xxx或者1.0xxxxx
浮点数加法 1对阶，2尾数求和，3尾数规范化 左规和右规。 4舍入 5检查是否溢出
全加法器是一个加法氮源，三端输入两段输出的加法网络。加法器的逻辑结构只涉及两个方面：一个是求和单元，另一个是进位链问题。
半加器是一个两端输入，两段输出的加法网络，也就是说半加器不需要进位的输入，而两个半加器可以组成一个全加器。
1.串行加法器 只用一个全加器
2.并行加法器 串行进位链 并行进位链：单重分组跳跃进位链，双重分组跳跃进位链
数字电路一般可分为组合逻辑电路和时序逻辑电路。组合逻辑电路热点是任意时刻的输出仅仅取决于该时刻的输入，运算后的结果立刻送到寄存器保存。
时序逻辑电路的特点是输出不仅取决于当时的输入信号，还取决于电路原来的状态。时序逻辑电路有记忆原件，即触发器，可以记录前一时刻的输出状态（cpu）
ALU是一种组合逻辑电路，使用alu时，输入端口a b与锁存器相连。
锁存器就是多位触发器，因为触发器只能存储以为，而一般参与运算的操作数都是多位的，所以引入锁存器。锁存器经常被用作运算器中的数据暂存器。以后看到锁存器就把它想象成一个临时存放数据的地方。
74181芯片是4位的alu电路，可见用四片74181芯片可以组成一个16位全加法器按四位一组的单重分组跳跃进位链。74181可完成16种算术运算和16中逻辑运算。
在8421BCD码中，1010到1111是不使用的。
大端法
最高有效字节在最前面的方式称为大端法，例如假设变量x类型为int型，位于地址0x100的地方，其16进制值为0x12345678，地址范围为0x100到0x103字节。

对于大端法的机器来说：

0x100	0x101	0x102	0x103
12	34	56	78
由上图可见，地址从左向右增长，x的最高有效字节12在最前面存储。这正好和我们平时书写习惯一致，先书写最高有效字节，再依次写其余字节。

小端法
最低有效字节在最前面的方式成为小端法，这正好和大端法相反，仍然用大端法中举的例子说明：

0x100	0x101	0x102	0x103
78	56	34	12
由上图可见，地址依然从左向右增长，x的最低有效字节在最前面存储，与大端法相反
循环冗余校验码进行检错的重要特性1，具有r检测位的多项式能够检测出所有长度小于或等于r的突发错误，2，长度大于r+1的错误逃脱的概率是1/2^r
计算机中表示地址时，采用无符号数
假设机器字长为n位，原码补码反码的上限都是1-2^-（n-1）
原码移位乘，符号位不参加运算，结果的符号位是两数符号位的异或，由于所有操作的数是真值的绝对值，没有正负可言，均是逻辑移位操作，高位加0。部分积相加中，可能两个小数大于1，因此部分积至少使用n+1个寄存器。
加法器采用先行进位的根本目的是快速传递进位信号。
