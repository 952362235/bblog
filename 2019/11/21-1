多重继承与虚继承
多重继承是指从多个直接基类中产生派生类的能力。
1.多重继承
多重继承的派生类从每个基类中继承状态
派生类构造函数初始化所有基类
继承的构造函数和多重继承
- 允许派生类从他的一个或几个人基类中继承构造函数，但是如果从多个基类中继承了相同的构造函数程序将产生错误。这个类必须为该构造函数定义自己的版本
析构函数和多重继承
多重继承的派生类的拷贝和移动操作
2.类型转换与多个基类
基于指针类型或引用类型的查找
3.多重继承下的类作用域
- 为了避免潜在的二义性，最好的方法就是在派生类中为函数定义一个新版本。
4.虚继承
虚继承的目的是令某个类做出声明，承诺愿意共享他的基类。其中共享的基类的子对象成为虚基类。在这种机制下，无论虚基类在继承体系中出现多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
- 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。
使用虚基类 - 是在派生列表中添加关键字virtual;
支持向基类的常规类型转换
虚基类成员的可见性
5.构造函数和虚继承
虚继承的对象的构造方式 - 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。
构造函数和析构函数的次序

命名空间
当应用程序用到多个供应商提供的库时，不可避免的会发生某些名字相互冲突的情况，多个库将名字放置在全局命名空间中将引发命名空间污染。
1.命名空间定义
- 一个命名空间的定义包含两部分，首先是关键字namespace，随后是名没看见的名字。在命名空间名字后面的是一系列由花括号括起来的声明和定义，只要能出现在全局作用域中的声明就能置于命名空间内。
- 命名空间作用域后面无须分号。
1）每个命名空间都是一个作用域
2）命名空间可以是不连续的
3)定义命名空间成员
4）模板特例化
5）全局命名空间
6）嵌套的命名空间
7）内联命名空间
8）未命名的命名空间 - 静态声明周期
2.使用命名空间成员
1）命名空间别名
2）using声明 扼要概述
3）using指示与作用域

控制内存与分配
某些应用对内存分配有特殊的要求，因此我们无法将标准内存管理机制直接应用于这些程序，他们常需要自定义内存分配的细节
比如使用new将对象放置在特定的内存空间中，为了实现这个目的，重载new和delete运算符以控制内存分配过程。
1.重载new和delete
使用一条new表达式时，实际执行了三步操作。1，调用operator new的标准库函数，分配内存空间。2，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。3，对象被分配了空间并构造完成，返回一个指向该对象的指针。
使用delet执行了两步操作。1，对sp所指的对象执行析构函数。2，编译器调用名为operator delete的标准库函数释放内存空间。
1）operator new 接口和operator delete接口
2) malloc函数和free函数
malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。
free接受一个void* ，他是malloc返回的指针的副本，free将相关内存返回系统，调用free(0)没有任何意义。
2.定位new表达式
当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。
显式的析构函数调用

运行时类型识别
run - time type identification, RTTI的功能由两个运算符实现：
1.typeid运算符，用于返回表达式的类型。
2.dynamic_cast运算符，用于将基类的指针或者引用安全的转换成派生类的指针或引用。
当我们无法定义一个虚函数，可以使用一个RTTI运算符。必须加倍小心，在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。
1.dynamic_cast运算符
1)指针类型的dynamic_cast
我们可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。
在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条表达式中完成。
2）引用类型的dynamic_cast
2.typeid运算符
typeid表达式的形式是typeid(e), 操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或type_info的公有派生类型。
如果表达式是一个引用，则typeid返回该引用所引对象的类型，不过作用于数组或函数时，并不会执行转换。也就是说对数组执行typeid，所得结果是数组类型而非指针类型。
1）使用typeid运算符
3.使用RTTI
有时候RTTI非常有用，比如我们想为具有继承关系的类实现相等运算符时。对于两个对象来说，如果他们的类型相同且对应的数据成员相同，则我们说这两个对象是相等的。
在类的继承体系中，每个派生类负责添加自己的数据成员，因此派生类的相等运算符必须把派生类的新成员考虑进来。
1）类的层次关系
2）类型敏感的相等运算符
4.type_info类
type_info没有默认构造函数，而且他的拷贝和移动构造函数以及赋值运算符都是被定义成删除的，因此创建type_info对象的唯一途径就是使用typeid运算符。


枚举类型
枚举类型使我们可以将一组整型常量组织在一起，和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。
cpp包括两种枚举：限定作用域和不限定作用域的。enum class 或者 enum
1）枚举成员 枚举成员是consst
2）和类一样，枚举也定义新的类型
一个不限定作用域的枚举类型的对象或枚举成员自动的转换成整型。而限定作用域的枚举类型不会进行隐式转换。
3）指定enum的大小    我们可以在enum的名字后面加上冒号以及我们想在该enum中使用的类型
4）枚举类型的前置声明
enum的前置声明（无论显示隐式）必须指定其成员的大小。不定域必须指明，限定作用域的enum可以隐式的定义。
5）形参匹配和枚举类型

类成员指针
成员指针是指可以指向类的非静态成员的指针。一般情况下指针指向一个对象，但是成员指针指向的是成员而不是对象。static不属于任何对象。
1.数据成员指针
与普通指针不同的是必须在 * 之前添加classname::以表示定义的指针可以指向classname的成员
auto pdata = &Screen::contents;
1)使用数据成员指针  .*或者->*
2）返回数据成员指针的函数
2.成员函数指针
1）使用成员函数指针
2）使用成员指针的类型别名
3）成员指针函数表
class Screen {
public:
	Screen& home();
	Screen& forward();
	Screen& back();
	Screen& up();
	Screen& down();
};
他们不接受任何参数，并且返回值是发生光标移动的screen的引用。
定义一个move函数，使其可以调用上面的函数并执行对应操作。为了支持这个函数，我们在screen中加入一个静态函数，该成员是指向光标移动函数的指针的数组。
class Screen {
public:
	usint Action = Screen & (Screen::*)();
	enum Directions {
		HOME, FORWARD,BACK,UP,DOWN
	};
private:
	static Action Menu[];
};
Screen& Screen::mobe(Directions cm)
{
	return (this->*Menu[cm]();
}
3.将成员函数用作可调用对象
1）使用function生成一个可调用对象
2）使用mem_fn生成一个可调用对象
3）使用bind生成一个可调用对象


嵌套类
一个类可以定义在另一个类的内部，前者称为嵌套类或嵌套类型。
嵌套类是个独立的类，与外层类基本没什么关系。
1）声明一个嵌套类
2）在外层类之外定义一个嵌套类
3）定义嵌套类的成员
4）嵌套类作用域中的名字查找
5)嵌套类和外层类是相互独立的


union：一种节省空间的类
联合是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成了未定义的状态。
union的成员都是公有的，这一点与struct相同。
union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能有虚函数。
1）定义union
2）使用union类型
3）匿名union  匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。
4）含有类类型成员的union
5）使用类管理union成员
对于union来说，想要构造或销毁类类型的成员必须执行非常复杂的操作，因此我们把含有类类型成员的union内嵌在另一个类中。
为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象成为union的判别式。
6）管理判别式并销毁string
7)管理需要拷贝控制的联合成员

局部类
类可以定义在某个函数的内部，我们称这样的类为局部类。局部类定义的类型只在定义他的作用域课件。和嵌套类不一样，局部类的成员收到严格的限制。
局部类中也不允许声明静态数据成员，因为我们没法定义这样的成员。
1）局部类不能使用函数作用域中的变量
2）常规的访问保护规则对局部类同样适用
3）局部类中的名字查找
4）嵌套的局部类

固有的不可抑制的特性
1）位域
类可以将其数据成员定义成位域，在一个位域中含有一定数量的二进制位。当一个程序员需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。
位域在内存中的布局是与机器相关的。
位域的类型必须是整型或枚举类型。声明形式是在成员名字之后跟：以及一个常量表达式。
取地址运算符&不能作用域位域，因此任何指针都无法指向类的位域。
通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。
使用位域
2）volatile限定符
volatile的确切含义与机器有关，只能通过阅读编译器文档来例假。要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变。
直接处理硬件的程序常常包含这样的数据元素，他们的值由程序直接控制之外的过程控制。当对象的值可能在程序的控制或检测之外被改变时，应该对改对象声明为volatile。
关键字volatile告诉编译器不应对这样的对象进行有货。
合成的拷贝对volatile无效
const和volatile的一个重要区别就是我们不能使用合成的拷贝/移动构造函数已经赋值运算符初始化volatile对象或从volatile对象赋值。
3）链接指示：extern“C”
C++使用链接指示指出任意非C++函数所用的语言。
要想把c++代码和其他语言编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前c++编译器是兼容的
1、声明一个非C++的函数
2、链接指示与头文件
3、指向extern“C”函数的指针
4、链接指示对整个声明都有效
5、导出C++函数到其他语言
6、重载函数与链接指示    c语言不支持函数重载
